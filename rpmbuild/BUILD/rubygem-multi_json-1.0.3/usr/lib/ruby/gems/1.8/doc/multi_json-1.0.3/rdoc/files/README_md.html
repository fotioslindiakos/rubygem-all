<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html 
     PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
     "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <title>File: README.md</title>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <meta http-equiv="Content-Script-Type" content="text/javascript" />
  <link rel="stylesheet" href=".././rdoc-style.css" type="text/css" media="screen" />
  <script type="text/javascript">
  // <![CDATA[

  function popupCode( url ) {
    window.open(url, "Code", "resizable=yes,scrollbars=yes,toolbar=no,status=no,height=150,width=400")
  }

  function toggleCode( id ) {
    if ( document.getElementById )
      elem = document.getElementById( id );
    else if ( document.all )
      elem = eval( "document.all." + id );
    else
      return false;

    elemStyle = elem.style;
    
    if ( elemStyle.display != "block" ) {
      elemStyle.display = "block"
    } else {
      elemStyle.display = "none"
    }

    return true;
  }
  
  // Make codeblocks hidden by default
  document.writeln( "<style type=\"text/css\">div.method-source-code { display: none }</style>" )
  
  // ]]>
  </script>

</head>
<body>



  <div id="fileHeader">
    <h1>README.md</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>README.md
      </td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Thu Sep 15 11:34:16 -0400 2011</td>
    </tr>
    </table>
  </div>
  <!-- banner header -->

  <div id="bodyContent">



  <div id="contextContent">

    <div id="description">
      <p>
MultiJSON
</p>
<h6>===</h6>
<p>
Lots of Ruby libraries utilize JSON parsing in some form, and everyone has
their favorite JSON library. In order to best support multiple JSON parsers
and libraries, <tt>multi_json</tt> is a general-purpose swappable JSON
backend library. You use it like so:
</p>
<pre>
    require 'multi_json'

    MultiJson.engine = :yajl
    MultiJson.decode('{&quot;abc&quot;:&quot;def&quot;}') # decoded using Yajl

    MultiJson.engine = :json_gem
    MultiJson.engine = MultiJson::Engines::JsonGem # equivalent to previous line
    MultiJson.encode({:abc =&gt; 'def'}) # encoded using the JSON gem
</pre>
<p>
The <tt>engine</tt> setter takes either a symbol or a class (to allow for
custom JSON parsers) that responds to both <tt>.decode</tt> and
<tt>.encode</tt> at the class level.
</p>
<p>
MultiJSON tries to have intelligent defaulting. That is, if you have any of
the supported engines already loaded, it will utilize them before
attempting to load any. When loading, libraries are ordered by speed. First
Yajl-Ruby, then the JSON gem, then JSON pure. If no JSON library is
available, MultiJSON falls back to a bundled version of [<a
href="../classes/OkJson.html">OkJson</a>](<a
href="https://github.com/kr/okjson">github.com/kr/okjson</a>).
</p>
<p>
Continuous Integration
</p>

    </div>


   </div>


  </div>


    <!-- if includes -->

    <div id="section">





      


    <!-- if method_list -->


  </div>


<div id="validator-badges">
  <p><small><a href="http://validator.w3.org/check/referer">[Validate]</a></small></p>
</div>

</body>
</html>